/* rvadtstamp.c - Windows adapter timestamp functions */
/************************************************************************
        Copyright (c) 2001 RADVISION Inc. and RADVISION Ltd.
************************************************************************
NOTICE:
This document contains information that is confidential and proprietary
to RADVISION Inc. and RADVISION Ltd.. No part of this document may be
reproduced in any form whatsoever without written prior approval by
RADVISION Inc. or RADVISION Ltd..

RADVISION Inc. and RADVISION Ltd. reserve the right to revise this
publication and make changes without obligation to notify any person of
such revisions or changes.
***********************************************************************/
#include "rvadtstamp.h"
#include "rvtime.h"


RvInt64 RvWinTimestampGet(void);
RvAdTimestampGet_f RvAdTimestampGet = RvWinTimestampGet;

static RvInt64 RvTickHz; /* Clock frequency (cycles/second) - set by Init */


RvStatus RvAdTimestampInit(void)
{
#if (RV_TIMESTAMP_TYPE == RV_TIMESTAMP_WIN32)
    LARGE_INTEGER Frequency;
#endif    

#if (RV_TIMESTAMP_TYPE == RV_TIMESTAMP_LINUX)
    FILE *cpuinfo;
    char linebuf[132], *cptr1, *cptr2;
    RvBool has_tsc, found_mhz;
    long scale, temp;
#endif
#if (RV_TIMESTAMP_TYPE == RV_TIMESTAMP_WIN32)
    if (QueryPerformanceFrequency(&Frequency) == 0)
    {
        RvTickHz = RvInt64Const(1,0,100000000); /* just to prevent accidental divide by zero */
        return RV_ERROR_UNKNOWN;
    }

    RvTickHz = (RvInt64)Frequency.QuadPart;
#endif    

#if (RV_TIMESTAMP_TYPE == RV_TIMESTAMP_LINUX)
    /* The only way to find out if the high performance timer (tsc) */
    /* is present and it's frequency is to read it from the file */
    /* /proc/cpuinfo which is generated by the kernel at boot time. */
    has_tsc = RV_FALSE;    /* mark when we have found if tsc is present */
    found_mhz = RV_FALSE;  /* mark when we have found and set the cpu speed */
    RvTickHz = RvInt64Const(1,0,100000000); /* just to prevent accidental divide by zero */
    cpuinfo = fopen("/proc/cpuinfo", "r");
	//printf("10\n");
    if(cpuinfo == NULL)
        return RV_ERROR_UNKNOWN;
	
    while(fgets(linebuf, sizeof(linebuf), cpuinfo) != NULL)
	{

        /* check for MHz line which will give clock (and tsc) speed */



//modfy by cl 20150514;linux and arm(hi3516)get cpuinfo different
        #ifdef _ARM_PLATFORM
		if(strncmp(linebuf, "BogoMIPS", 8) == 0)
		#else	
        if(strncmp(linebuf, "cpu MHz", 7) == 0)
		#endif
		{
            /* line contains cpu speed info, parse it into RvTickHz */
            cptr1 = strchr(linebuf, ':');  /* find start of data field */
            if (cptr1 != NULL)
			{
                cptr1++;                   /* skip ":" seperator */
                cptr2= strchr(cptr1, '.'); /* find decimal point */
                if(cptr2 != NULL) {        /* it had better be there */
                    *cptr2 = '\0';         /* split number into parts */
                    cptr2++;               /* move to start of decimal */
                    temp = strtol(cptr1, NULL, 0); /* read whole number */
                    if(temp > 0) {         /* sanity check */
                        RvTickHz = RvInt64Const(1,0,1000000) * (RvInt64)temp;
                        /* now add variable lengh fraction amount */
                        scale = 100000L;    /* scale of next digit */
                        while((scale > 0L) && (isdigit(*cptr2) != 0))
						{
                            temp = (long)(*cptr2 - '0');
                            RvTickHz += (RvInt64)(temp * scale);
                            scale = scale / 10L;
                            cptr2++;
                        }
                        found_mhz = RV_TRUE;
                    }
                }
            }
        } /* end of cpu MHz check/parse */

#ifndef _ARM_PLATFORM
        /* check for "flags" line which lists tsc if it is present */
        if(strncmp(linebuf, "flags", 5) == 0)
		{
            cptr1 = strchr(linebuf, ':'); /* find start of data field */
            if (cptr1 != NULL)
			{
                cptr2 = strstr(cptr1, " tsc"); /* see if tsc is there */
                if(cptr2 != NULL) has_tsc = RV_TRUE;
            }
        }
#else
		//add cl 20150514
		
		has_tsc = RV_TRUE;
#endif
		

    } /* end of file read loop */
    fclose(cpuinfo);

#ifdef _ARM_A8
    cpuinfo = fopen("/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq", "r");
    if(cpuinfo == NULL)
        return RV_ERROR_UNKNOWN;

    if(fgets(linebuf, sizeof(linebuf), cpuinfo) != NULL)
    {
        temp = strtol(linebuf, NULL, 0);
        printf("temp is ..........%d..\n",temp);
        if(temp > 0)
        {
            RvTickHz = RvInt64Const(1,0,1000000) * ((RvInt64)temp/1000);
            found_mhz = RV_TRUE;
        }
    }
    fclose(cpuinfo);
#endif

    if(has_tsc == RV_FALSE)
    {
	   return RV_ERROR_UNKNOWN;
    }
    if(found_mhz == RV_FALSE)
    {
        return RV_ERROR_UNKNOWN;
    }
#endif

    return RV_OK;
}


void RvAdTimestampEnd(void)
{
}


RvInt64 RvWinTimestampGet(void)
{
    RvInt64 result;
#if (RV_TIMESTAMP_TYPE == RV_TIMESTAMP_LINUX)
    unsigned long eax,edx;
    RvInt64 tickcount;
#endif
//modfy by cl 20150512
#ifdef _ARM_PLATFORM
#if (RV_TIMESTAMP_TYPE == RV_TIMESTAMP_EMBLINUX) 
    struct timeval {
        long tv_sec; /* timeval structure */ /*h.e ??? */
        long tv_usec;
    };
    struct timeval tv;  

#endif
#endif
#if (RV_TIMESTAMP_TYPE == RV_TIMESTAMP_WIN32)
    LARGE_INTEGER PerformanceCount;
#endif

#if (RV_TIMESTAMP_TYPE == RV_TIMESTAMP_LINUX)


//modfy by cl 20150512

	// rdtsc(eax,edx);
#ifndef _ARM_PLATFORM
    __asm__ __volatile__
    (
        "rdtsc":"=a"(eax),"=d"(edx)
    );
	tickcount = (RvInt64)edx * (RvInt64)ULONG_MAX + (RvInt64)edx + (RvInt64)eax;
#else

	struct timeval t1,t2;
    gettimeofday(&t1,NULL);
    gettimeofday(&t2,NULL);
    tickcount = (t2.tv_sec-t1.tv_sec)*1000000 +(t2.tv_usec-t1.tv_usec);
#endif
	
    /* convert to nanosecs and maintain resolution, works up to about */
    /* a 9 gigaherz clock */
    result = (tickcount / RvTickHz) * RV_TIME64_NSECPERSEC;
    result += (((tickcount % RvTickHz) * RV_TIME64_NSECPERSEC) / RvTickHz);
#endif

#if 0
#if (RV_TIMESTAMP_TYPE == RV_TIMESTAMP_EMBLINUX)
    gettimeofday(&tv, NULL);
    result = ((RvInt64)tv.tv_sec * RV_TIME64_NSECPERSEC) + ((RvInt64)tv.tv_usec * RV_TIME64_NSECPERUSEC);
#endif
#endif
#if (RV_TIMESTAMP_TYPE == RV_TIMESTAMP_WIN32)
    QueryPerformanceCounter(&PerformanceCount);
    
    /* convert to nanoseconds and maintain resolution */
    result = (PerformanceCount.QuadPart / RvTickHz) * RV_TIME64_NSECPERSEC;
    result += (((PerformanceCount.QuadPart % RvTickHz) * RV_TIME64_NSECPERSEC) / RvTickHz);
#endif
    return result;
}


RvInt64 RvAdTimestampResolution(void)
{
    RvInt64 result;

    if(RvInt64IsGreaterThan(RvTickHz, RvInt64Const(1,0,1)))
        result = RvInt64Div(RV_TIME64_NSECPERSEC, RvTickHz);
    else
        result = RV_TIME64_NSECPERSEC;
    
    return result;
}
